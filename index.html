<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>å•†å“ç”»åƒãƒªã‚µã‚¤ã‚ºï¼ˆ650x528 / ICC / ZIPï¼‰</title>
  <style>
    :root{
      --bg:#0b0f14; --panel:#111a24; --line:#22303e; --text:#e6edf3; --muted:#93a4b5;
      --warn:#ffcc66; --err:#ff6b6b; --ok:#6bff95;
      --tile: 180px;
    }
    *{box-sizing:border-box}
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Noto Sans JP,Helvetica,Arial,sans-serif;background:var(--bg);color:var(--text)}
    header{padding:28px 14px 14px;border-bottom:1px solid var(--line);display:flex;flex-direction:column;gap:10px;align-items:stretch}
    header h1{font-size:14px;margin:0}
    .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    label{font-size:12px;color:var(--muted)}
    input[type="text"]{height:28px;padding:0 10px;border:1px solid var(--line);border-radius:8px;background:#0f1620;color:var(--text)}
    input[type="file"]{font-size:12px;color:var(--muted)}
    button{
      height:30px;padding:0 12px;border:1px solid var(--line);border-radius:10px;
      background:#132033;color:var(--text);cursor:pointer
    }
    button:disabled{opacity:.5;cursor:not-allowed}

    header h1{margin:0;font-size:14px}
    input[type="file"]{width:380px;max-width:100%}
    .outname{font-size:12px;color:var(--muted);line-height:1.2;word-break:break-all}
    .trash{
      width:34px;height:34px;min-width:34px;min-height:34px;flex:0 0 34px;
      display:flex;align-items:center;justify-content:center;
      border:1px dashed rgba(255,107,107,.7);border-radius:10px;background:rgba(255,107,107,.08);
      user-select:none;overflow:hidden;contain:layout paint;
    }
    .trash{transition: background .12s ease, border-color .12s ease, box-shadow .12s ease, color .12s ease, transform .12s ease;}
    .trash.hi{background:rgba(255,107,107,.22);border-color:rgba(255,107,107,.95);box-shadow:0 0 0 2px rgba(255,107,107,.25) inset;color:#ff6b6b;transform:scale(1.06)}

    .container{padding:14px;display:grid;gap:12px}
    .drop{
      border:1px dashed #3a4b5f;border-radius:14px;padding:16px;background:rgba(17,26,36,.6);
      display:flex;justify-content:space-between;align-items:center;gap:10px;flex-wrap:wrap
    }
    .drop strong{font-size:13px}
    .drop span{font-size:12px;color:var(--muted)}
    .grid{
      display:grid;
      grid-template-columns: repeat(auto-fill, minmax(var(--tile), 1fr));
      gap:12px
    }
    .card{
      border:1px solid var(--line);border-radius:14px;background:var(--panel);
      overflow:hidden;position:relative
    }
    .thumb{
      width:100%;height:140px;background:#0f1620;display:flex;align-items:center;justify-content:center;
      border-bottom:1px solid var(--line)
    }
    .thumb img, .thumb canvas{max-width:100%;max-height:100%;display:block}
    .meta{padding:10px;display:grid;gap:6px}
    .fname{font-size:12px;line-height:1.2;word-break:break-all}
    .badges{display:flex;gap:6px;flex-wrap:wrap}
    .badge{
      font-size:11px;border:1px solid var(--line);border-radius:999px;padding:2px 8px;color:var(--muted)
    }
    .badge.warn{border-color:rgba(255,204,102,.5);color:var(--warn)}
    .badge.err{border-color:rgba(255,107,107,.5);color:var(--err)}
    .badge.ok{border-color:rgba(107,255,149,.5);color:var(--ok)}
    .seq{
      position:absolute;left:10px;top:10px;background:rgba(0,0,0,.55);
      border:1px solid rgba(255,255,255,.15);border-radius:999px;padding:3px 8px;font-size:12px
    }
    .exclude{
      position:absolute;right:10px;top:10px;display:flex;align-items:center;gap:6px;
      background:rgba(0,0,0,.55);border:1px solid rgba(255,255,255,.15);border-radius:999px;padding:3px 8px;
      font-size:12px
    }
    .exclude input{width:14px;height:14px}
    .small{font-size:12px;color:var(--muted)}
    .footer{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    .log{
      border:1px solid var(--line);border-radius:14px;background:#0f1620;padding:10px;white-space:pre-wrap;
      font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;font-size:12px;color:var(--muted)
    }
      .ver{position:fixed;left:6px;top:6px;font-size:11px;color:#ff3b3b;z-index:9999;pointer-events:none;}
  
    /* confirm modal */
    .modal{
      position:fixed;inset:0;z-index:10000;
      display:flex;align-items:center;justify-content:center;
      background:rgba(0,0,0,.55);
    }
    .modal.hidden{display:none}
    .modalCard{
      width:min(420px, calc(100vw - 28px));
      border:1px solid var(--line);
      border-radius:14px;
      background:#0f1620;
      box-shadow:0 18px 50px rgba(0,0,0,.45);
      padding:14px;
    }
    .modalTitle{font-size:13px;margin:0 0 8px 0}
    .modalMsg{font-size:12px;color:var(--muted);line-height:1.5;white-space:pre-wrap;margin:0 0 12px 0}
    .modalActions{display:flex;gap:10px;justify-content:flex-end}
    .btnDanger{border-color:rgba(255,107,107,.55);box-shadow:0 0 0 1px rgba(255,107,107,.12) inset}

  </style>
</head>
<body>
  <div class="ver">Ver_1.1.0</div>

  <div id="confirmOverlay" class="modal hidden" aria-hidden="true">
    <div class="modalCard" role="dialog" aria-modal="true" aria-labelledby="confirmTitle" aria-describedby="confirmMsg">
      <div class="modalTitle" id="confirmTitle">ç¢ºèª</div>
      <div class="modalMsg" id="confirmMsg"></div>
      <div class="modalActions">
        <button id="confirmCancel" type="button">æˆ»ã‚‹</button>
        <button id="confirmOk" type="button" class="btnDanger">OK</button>
      </div>
    </div>
  </div>
  <header>
    <h1>å•†å“ç”»åƒãƒªã‚µã‚¤ã‚ºï¼ˆ650Ã—528 / JPEG Q100 / 144dpi / ICCâ†’sRGB / ZIPï¼‰</h1>

    <div class="row">
      <label>å›ºå®šåï¼ˆZIPåã«ã‚‚ä½¿ç”¨ï¼‰</label>
      <input id="prefix" type="text" value="260000pickup" />
    </div>

    <div class="row">
      <label>sRGB IEC61966-2.1</label>
      <input id="srgbIcc" type="file" accept=".icc,.icm,application/octet-stream" />
      <label>Japan Color 2001 Coated ICC</label>
      <input id="japanIcc" type="file" accept=".icc,.icm,application/octet-stream" />
    </div>

    <div class="row">
      <button id="btnDummy" type="button">ãƒ€ãƒŸãƒ¼è¿½åŠ </button>
      <button id="btnExport" disabled>ZIPã‚’æ›¸ãå‡ºã—</button>
      <button id="btnClear">ã‚¯ãƒªã‚¢</button>
      <div id="trash" class="trash" title="ã“ã“ã«ãƒ‰ãƒ©ãƒƒã‚°ã§å‰Šé™¤">ğŸ—‘</div>
      <span id="status" class="small">åˆæœŸåŒ–ä¸­â€¦</span>
    </div>
  </header>

  <div class="container">
    <div id="drop" class="drop">
      <div>
        <strong>ã“ã“ã«ç”»åƒ / PDF ã‚’ãƒ‰ãƒ©ãƒƒã‚°ï¼†ãƒ‰ãƒ­ãƒƒãƒ—</strong><br />
        <span>æŠ•å…¥å¾Œã«ã‚¿ã‚¤ãƒ«è¡¨ç¤º â†’ ä¸¦ã³æ›¿ãˆ â†’ é™¤å¤–ãƒã‚§ãƒƒã‚¯ â†’ ZIPå‡ºåŠ›</span>
      </div>
      <div class="footer">
        <span class="small">å‡ºåŠ›: 650Ã—528 / ç™½ä½™ç™½ / Q100 / 144dpi / sRGB</span>
      </div>
    </div>

    <div id="grid" class="grid"></div>

    <div id="log" class="log">Log:</div>
  </div>

  <!-- SortableJS -->
  <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.2/Sortable.min.js"></script>

  <!-- JSZip -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

  <!-- pdf.js (ESM) + magick-wasm (ESM) -->
  <script type="module">
    import * as Magick from "https://cdn.jsdelivr.net/npm/@imagemagick/magick-wasm@0.0.37/dist/index.js";
    import * as pdfjsLib from "https://cdn.jsdelivr.net/npm/pdfjs-dist@4.10.38/build/pdf.mjs";

    // ---- constants ----
    const TARGET_W = 650;
    const TARGET_H = 528;
    const OUT_DPI = 144;
    const OUT_QUALITY = 100;

    // pdf.js worker
    pdfjsLib.GlobalWorkerOptions.workerSrc =
      "https://cdn.jsdelivr.net/npm/pdfjs-dist@4.10.38/build/pdf.worker.mjs";

    // ---- state ----
    /** @type {{id:string, file:File, kind:"image"|"pdf"|"dummy", excluded:boolean, warnings:string[], info:{colorSpace?:string, hasIcc?:boolean}|null, thumbUrl?:string, thumbCanvas?:HTMLCanvasElement}[]} */
    const items = [];

    // ---- warn on refresh / tab close when there are items ----
    window.addEventListener("beforeunload", (e) => {
      // Show standard browser warning only when there is something in the list.
      if (items.length === 0) return;
      e.preventDefault();
      // Most browsers ignore the custom message and show a standard prompt.
      e.returnValue = "";
    });

    let srgbProfile = null;       // Magick.ColorProfile
    let japanProfile = null;      // Magick.ColorProfile
    let magickReady = false;

    // ---- dom ----
    const elGrid = document.getElementById("grid");
    const elDrop = document.getElementById("drop");
    const elPrefix = document.getElementById("prefix");
    const elBtnExport = document.getElementById("btnExport");
    const elBtnClear = document.getElementById("btnClear");
    const elBtnDummy = document.getElementById("btnDummy");
    const elStatus = document.getElementById("status");
    const elLog = document.getElementById("log");
    // ---- confirm modal ----
    const elConfirmOverlay = document.getElementById("confirmOverlay");
    const elConfirmTitle = document.getElementById("confirmTitle");
    const elConfirmMsg = document.getElementById("confirmMsg");
    const elConfirmOk = document.getElementById("confirmOk");
    const elConfirmCancel = document.getElementById("confirmCancel");

    function showConfirm({ title="ç¢ºèª", message="", okText="OK", cancelText="æˆ»ã‚‹", okDanger=false } = {}){
      return new Promise((resolve)=>{
        let done = false;
        const finish = (v)=>{
          if(done) return;
          done = true;
          elConfirmOverlay.classList.add("hidden");
          elConfirmOverlay.setAttribute("aria-hidden","true");
          cleanup();
          resolve(v);
        };
        const onKey = (e)=>{
          if(e.key === "Escape") finish(false);
          if(e.key === "Enter") finish(true);
        };
        const onBackdrop = (e)=>{
          if(e.target === elConfirmOverlay) finish(false);
        };
        const cleanup = ()=>{
          elConfirmOk.removeEventListener("click", onOk);
          elConfirmCancel.removeEventListener("click", onCancel);
          document.removeEventListener("keydown", onKey);
          elConfirmOverlay.removeEventListener("mousedown", onBackdrop);
        };
        const onOk = ()=>finish(true);
        const onCancel = ()=>finish(false);

        elConfirmTitle.textContent = title;
        elConfirmMsg.textContent = message;
        elConfirmOk.textContent = okText;
        elConfirmCancel.textContent = cancelText;

        elConfirmOk.classList.toggle("btnDanger", !!okDanger);

        elConfirmOverlay.classList.remove("hidden");
        elConfirmOverlay.setAttribute("aria-hidden","false");
        elConfirmOk.focus();

        elConfirmOk.addEventListener("click", onOk);
        elConfirmCancel.addEventListener("click", onCancel);
        document.addEventListener("keydown", onKey);
        elConfirmOverlay.addEventListener("mousedown", onBackdrop);
      });
    }

    const elSrgbIcc = document.getElementById("srgbIcc");
    const elJapanIcc = document.getElementById("japanIcc");

    function log(msg){
      elLog.textContent += "\\n" + msg;
      elLog.scrollTop = elLog.scrollHeight;
    }

    function setStatus(msg){ elStatus.textContent = msg; }

    function pad(num, width){
      const s = String(num);
      return s.length >= width ? s : "0".repeat(width - s.length) + s;
    }


    // â˜…é‡è¦ï¼šMagickã®writeãŒè¿”ã™dataã¯å¯¿å‘½ãŒçŸ­ã„ã®ã§ã€å¿…ãšã‚³ãƒ”ãƒ¼ã—ã¦ä¿æŒã™ã‚‹
    async function magickWriteCopyU8(img, format){
      let out = null;
      const maybePromise = img.write(format, (data) => {
        out = new Uint8Array(data); // ã“ã“ã§ã‚³ãƒ”ãƒ¼
      });
      if(maybePromise && typeof maybePromise.then === "function"){
        await maybePromise;
      }
      if(!out || out.length < 4){
        throw new Error("JPEGæ›¸ãå‡ºã—ã«å¤±æ•—ã—ã¾ã—ãŸï¼ˆå‡ºåŠ›ãŒç©ºï¼‰");
      }
      // JPEG SOI (FF D8)
      if(!(out[0] === 0xFF && out[1] === 0xD8)){
        throw new Error("JPEGæ›¸ãå‡ºã—ãŒå£Šã‚Œã¦ã„ã¾ã™ï¼ˆSOIãŒã‚ã‚Šã¾ã›ã‚“ï¼‰");
      }
      return out;
    }

    function currentDigits(){
      // ã€Œå…¥åŠ›ç·æ•°ã€ãŒ100è¶…ãˆãŸã‚‰3æ¡ï¼ˆé™¤å¤–ã—ã¦ã‚‚è©°ã‚ãªã„é‹ç”¨ãªã®ã§ã€ç·æ•°åŸºæº–ã«ã™ã‚‹ï¼‰
      return items.length >= 100 ? 3 : 2;
    }

    function refreshSeqBadges(){
      const cards = [...elGrid.querySelectorAll(".card")];
      const digits = currentDigits();
      const prefix = (elPrefix.value || "").trim() || "output";
      cards.forEach((card, idx)=>{
        const seq = idx + 1;
        const seqStr = pad(seq, digits);
        const seqEl = card.querySelector(".seq");
        if(seqEl) seqEl.textContent = seqStr;

        const outEl = card.querySelector(".outname");
        if(outEl) outEl.textContent = `${prefix}${seqStr}.jpg`;
      });
      // exportãƒœã‚¿ãƒ³
      elBtnExport.disabled = !magickReady || items.length === 0;
    }

    function updateItemOrderFromDOM(){
      const cards = [...elGrid.querySelectorAll(".card")];
      const newOrder = [];
      for(const card of cards){
        const id = card.dataset.id;
        const it = items.find(x=>x.id===id);
        if(it) newOrder.push(it);
      }
      items.length = 0;
      items.push(...newOrder);
      refreshSeqBadges();
    }

    function makeCard(it){
      const card = document.createElement("div");
      card.className = "card";
      card.dataset.id = it.id;

      const seq = document.createElement("div");
      seq.className = "seq";
      seq.textContent = "??";

      const exclude = document.createElement("label");
      exclude.className = "exclude";
      exclude.innerHTML = '<input type="checkbox" />é™¤å¤–';
      const chk = exclude.querySelector("input");
      chk.checked = it.excluded;
      chk.addEventListener("change", ()=>{
        it.excluded = chk.checked;
        refreshSeqBadges(); // é€£ç•ªã¯è©°ã‚ãªã„ãŒã€UIæ›´æ–°ã¯å¿…è¦
      });

      const thumb = document.createElement("div");
      thumb.className = "thumb";
      if(it.thumbCanvas){
        thumb.appendChild(it.thumbCanvas);
      }else{
        const img = document.createElement("img");
        img.alt = it.file.name;
        img.src = it.thumbUrl || "";
        thumb.appendChild(img);
      }

      const meta = document.createElement("div");
      meta.className = "meta";

      const fname = document.createElement("div");
      fname.className = "fname";
      fname.textContent = it.file.name;

      

      const outname = document.createElement("div");
      outname.className = "outname";
      outname.textContent = "";const badges = document.createElement("div");
      badges.className = "badges";

      // kind badge
      const bKind = document.createElement("span");
      bKind.className = "badge";
      bKind.textContent = it.kind.toUpperCase();
      badges.appendChild(bKind);

      // info badges
      if(it.info){
        const bCS = document.createElement("span");
        bCS.className = "badge";
        bCS.textContent = it.info.colorSpace ?? "Color: ?";
        badges.appendChild(bCS);

        const bICC = document.createElement("span");
        bICC.className = "badge";
        bICC.textContent = it.info.hasIcc ? "ICC: yes" : "ICC: no";
        badges.appendChild(bICC);
      }

      // warnings
      for(const w of it.warnings){
        const b = document.createElement("span");
        b.className = "badge warn";
        b.textContent = w;
        badges.appendChild(b);
      }

      meta.appendChild(fname);
      meta.appendChild(outname);
      meta.appendChild(badges);

      card.appendChild(seq);
      card.appendChild(exclude);
      card.appendChild(thumb);
      card.appendChild(meta);
      return card;
    }

    async function readFileAsU8(file){
      return new Uint8Array(await file.arrayBuffer());
    }

    async function tryAutoLoadProfiles(){
      // åŒæ¢±é‹ç”¨ã—ãŸã„å ´åˆï¼š/profiles/ ã«ç½®ã
      // â€»ãƒ•ã‚¡ã‚¤ãƒ«åã¯å¿…è¦ã«å¿œã˜ã¦å¤‰æ›´OKï¼ˆã“ã“ã¯ã€ŒãŸãŸãå°ã€ï¼‰
      const srgbPath = "profiles/sRGB IEC61966-2.1.icc";
      const jpPath   = "profiles/JapanColor2001Coated.icc";

      async function fetchU8(path){
        const res = await fetch(path);
        if(!res.ok) return null;
        return new Uint8Array(await res.arrayBuffer());
      }

      const s = await fetchU8(srgbPath);
      if(s) {
        srgbProfile = new Magick.ColorProfile(s);
        log("sRGB ICC auto loaded: " + srgbPath);
      } else {
        log("sRGB ICC not found at " + srgbPath + "ï¼ˆæ‰‹å‹•æŒ‡å®šã§ãã¾ã™ï¼‰");
      }

      const j = await fetchU8(jpPath);
      if(j){
        japanProfile = new Magick.ColorProfile(j);
        log("Japan Color ICC auto loaded: " + jpPath);
      } else {
        log("Japan Color ICC not found at " + jpPath + "ï¼ˆæ‰‹å‹•æŒ‡å®šã§ãã¾ã™ï¼‰");
      }
    }

    async function setProfileFromInput(file, which){
      const u8 = await readFileAsU8(file);
      const prof = new Magick.ColorProfile(u8);
      if(which === "srgb") srgbProfile = prof;
      if(which === "japan") japanProfile = prof;
      log(which + " ICC loaded: " + file.name);
    }

    function isPdf(file){
      return file.type === "application/pdf" || /\.pdf$/i.test(file.name);
    }

    function isTiff(file){
      return file.type === "image/tiff" || /\.tiff?$/i.test(file.name);
    }

    function makePlaceholderCanvas(label){
      const c = document.createElement("canvas");
      c.width = 320;
      c.height = 180;
      c.dataset.placeholder = "1";
      const ctx = c.getContext("2d");
      ctx.fillStyle = "#0f1620";
      ctx.fillRect(0, 0, c.width, c.height);
      ctx.strokeStyle = "#22303e";
      ctx.lineWidth = 2;
      ctx.strokeRect(1, 1, c.width - 2, c.height - 2);
      ctx.fillStyle = "#93a4b5";
      ctx.font = "bold 28px system-ui, -apple-system, Segoe UI, Roboto, Noto Sans JP, Helvetica, Arial, sans-serif";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(label, c.width / 2, c.height / 2);
      return c;
    }

    function makeSolidCanvas(w, h, color, labelText){
      const c = document.createElement("canvas");
      c.width = w;
      c.height = h;
      const ctx = c.getContext("2d");
      ctx.fillStyle = color;
      ctx.fillRect(0, 0, w, h);

      // optional label (subtle)
      if(labelText){
        ctx.fillStyle = "rgba(0,0,0,.35)";
        ctx.font = "bold 28px system-ui, -apple-system, Segoe UI, Roboto, Noto Sans JP, Helvetica, Arial, sans-serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(labelText, w/2, h/2);
      }
      return c;
    }

    function makeDummyThumbCanvas(){
      // ã‚µãƒ ãƒã¯ã‚¿ã‚¤ãƒ«æ ã«åã¾ã‚‹ç¨‹åº¦ã§OK
      return makeSolidCanvas(320, 180, "#b0b8bb", "DUMMY");
    }

    function makeDummyExportCanvas(){
      // å‡ºåŠ›ç”¨ãƒ€ãƒŸãƒ¼ï¼ˆ#b0b8bb / 650x528ï¼‰
      return makeSolidCanvas(TARGET_W, TARGET_H, "#b0b8bb", null);
    }

    async function buildTiffThumbnailUrl(file){
      // TIFFã¯ãƒ–ãƒ©ã‚¦ã‚¶ã®<img>ã§ç›´æ¥è¡¨ç¤ºã§ããªã„ã“ã¨ãŒå¤šã„ã®ã§ã€magick-wasmã§ã‚µãƒ ãƒã‚’ä½œã‚‹
      const u8 = await readFileAsU8(file);
      return await Magick.ImageMagick.read(u8, async (img) => {
        try{
          try{ img.autoOrient(); } catch {}
          img.backgroundColor = Magick.MagickColors.White;
          try{ img.alpha(Magick.AlphaAction.Remove); } catch {}

          // ã‚µãƒ ãƒã¯è»½é‡å„ªå…ˆï¼ˆè¦‹ãŸç›®ç¢ºèªç”¨ï¼‰
          const MAX_W = 320;
          const MAX_H = 240;
          const dims = containResizeDims(img.width, img.height, MAX_W, MAX_H);
          img.resize(dims.w, dims.h);

          img.quality = 85;
          const thumbU8 = await magickWriteCopyU8(img, Magick.MagickFormat.Jpeg);
          const blob = new Blob([thumbU8], { type: "image/jpeg" });
          return URL.createObjectURL(blob);
        } finally {
          img.dispose();
        }
      });
    }

    async function refreshTiffThumbnails(){
      // åˆæœŸåŒ–å‰ã«æŠ•å…¥ã•ã‚ŒãŸTIFFã‚’ã€åˆæœŸåŒ–å¾Œã«ã‚µãƒ ãƒç”Ÿæˆã—ã¦å·®ã—æ›¿ãˆã‚‹
      const tasks = [];
      for(const it of items){
        if(it.kind !== "image") continue;
        if(!isTiff(it.file)) continue;
        if(it.thumbUrl && !it.thumbCanvas) continue;

        tasks.push((async () => {
          try{
            const url = await buildTiffThumbnailUrl(it.file);
            it.thumbUrl = url;
            delete it.thumbCanvas;
            it.warnings = (it.warnings || []).filter(w => w !== "TIFFã‚µãƒ ãƒã¯åˆæœŸåŒ–å¾Œ");

            const card = elGrid.querySelector(`.card[data-id="${it.id}"]`);
            if(card){
              const thumbDiv = card.querySelector(".thumb");
              if(thumbDiv){
                thumbDiv.innerHTML = "";
                const img = document.createElement("img");
                img.alt = it.file.name;
                img.src = it.thumbUrl || "";
                thumbDiv.appendChild(img);
              }
            }
          } catch (e) {
            // å¤±æ•—æ™‚ã¯ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ã®ã¾ã¾
            if(!it.thumbCanvas) it.thumbCanvas = makePlaceholderCanvas("TIFF");
            if(!(it.warnings || []).includes("TIFFã‚µãƒ ãƒå¤±æ•—")) it.warnings.push("TIFFã‚µãƒ ãƒå¤±æ•—");
          }
        })());
      }
      if(tasks.length){
        await Promise.all(tasks);
      }
    }


    async function buildPdfThumbnailAndInfo(file){
      // ä½è² è·ã®ã‚µãƒ ãƒç”¨ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°
      const data = await file.arrayBuffer();
      const pdf = await pdfjsLib.getDocument({ data }).promise;
      const page = await pdf.getPage(1);
      const viewport = page.getViewport({ scale: 0.3 });

      const canvas = document.createElement("canvas");
      canvas.width = Math.max(1, Math.floor(viewport.width));
      canvas.height = Math.max(1, Math.floor(viewport.height));
      const ctx = canvas.getContext("2d", { alpha: false });

      await page.render({ canvasContext: ctx, viewport }).promise;

      return {
        canvas,
        info: { colorSpace: "PDF", hasIcc: false },
        warnings: ["PDFã¯1ãƒšãƒ¼ã‚¸ç›®ã®ã¿"]
      };
    }

    async function analyzeImageWithMagick(u8){
      // ã‚µãƒ ãƒã®è­¦å‘Šè¡¨ç¤ºç”¨ï¼šcolorspace / ICCæœ‰ç„¡ã ã‘è¦‹ã‚‹
      return await Magick.ImageMagick.read(u8, (img) => {
        try{
          const cs = img.colorSpace;
          const csName = Object.keys(Magick.ColorSpace).find(k => Magick.ColorSpace[k] === cs) ?? String(cs);
          const hasIcc = img.hasProfile("icc") || (img.getColorProfile() !== null);
          return { colorSpace: csName, hasIcc };
        } finally {
          img.dispose();
        }
      });
    }


    function addDummy(){
      const id = crypto.randomUUID();
      // Fileã‚’å®Ÿä½“ã¨ã—ã¦æŒãŸã›ã‚‹ï¼ˆåå‰è¡¨ç¤ºç”¨ï¼‰ã€‚ä¸­èº«ã¯ç©ºã§OKï¼ˆdummyã¯å°‚ç”¨å‡¦ç†ã§æ›¸ãå‡ºã™ï¼‰
      const file = new File([], "DUMMY", { type: "application/octet-stream" });

      const it = {
        id,
        file,
        kind: "dummy",
        excluded: false,
        warnings: [],
        info: { colorSpace: "DUMMY", hasIcc: false },
        thumbCanvas: makeDummyThumbCanvas()
      };

      items.push(it);
      elGrid.appendChild(makeCard(it));
      refreshSeqBadges();
      log("dummy added");
    }

    async function addFiles(files){
      for(const file of files){
        const id = crypto.randomUUID();
        const it = { id, file, kind: isPdf(file) ? "pdf" : "image", excluded:false, warnings:[], info:null };

        if(it.kind === "pdf"){
          const { canvas, info, warnings } = await buildPdfThumbnailAndInfo(file);
          it.thumbCanvas = canvas;
          it.info = info;
          it.warnings.push(...warnings);
        } else {
          if(isTiff(file)){
            it.warnings.push("TIFF");
            if(magickReady){
              try{
                it.thumbUrl = await buildTiffThumbnailUrl(file);
              }catch(e){
                it.warnings.push("TIFFã‚µãƒ ãƒå¤±æ•—");
                it.thumbCanvas = makePlaceholderCanvas("TIFF");
              }
            } else {
              it.warnings.push("TIFFã‚µãƒ ãƒã¯åˆæœŸåŒ–å¾Œ");
              it.thumbCanvas = makePlaceholderCanvas("TIFF");
            }
          } else {
            it.thumbUrl = URL.createObjectURL(file);
          }

          // magickã§è§£æï¼ˆCMYKæ¤œçŸ¥ãªã©ï¼‰
          try{
            const u8 = await readFileAsU8(file);
            it.info = await analyzeImageWithMagick(u8);

            // CMYKãªã‚‰è­¦å‘Šï¼ˆï¼JapanColorâ†’sRGBå¤‰æ›ãŒå¿…è¦ï¼‰
            if(it.info.colorSpace === "CMYK" || it.info.colorSpace === "CMY"){
              it.warnings.push("CMYKå…¥åŠ›");
              if(!japanProfile) it.warnings.push("JapanColor ICCæœªæŒ‡å®š");
            } else {
              // RGBã§ICCç„¡ã—ã¯è­¦å‘Šï¼ˆsRGBæ‰±ã„ã«ã™ã‚‹ï¼‰
              if(!it.info.hasIcc) it.warnings.push("ICCãªã—â†’sRGBæ‰±ã„");
            }
          }catch(e){
            it.warnings.push("è§£æå¤±æ•—");
            log("analyze error: " + file.name + " / " + (e?.message ?? e));
          }
        }

        items.push(it);
        elGrid.appendChild(makeCard(it));
      }

      refreshSeqBadges();
    }

    async function rasterizePdfToCanvas(file){
      const data = await file.arrayBuffer();
      const pdf = await pdfjsLib.getDocument({ data }).promise;
      const page = await pdf.getPage(1);

      // å‡ºåŠ›650x528ã«å¯¾ã—ã¦ååˆ†ãªè§£åƒã‚’ç¢ºä¿ï¼ˆ2å€ç›®å®‰ï¼‰
      const base = page.getViewport({ scale: 1 });
      const scale = Math.max((TARGET_W * 2) / base.width, (TARGET_H * 2) / base.height);
      const viewport = page.getViewport({ scale });

      const canvas = document.createElement("canvas");
      canvas.width = Math.max(1, Math.floor(viewport.width));
      canvas.height = Math.max(1, Math.floor(viewport.height));
      const ctx = canvas.getContext("2d", { alpha: false });

      await page.render({ canvasContext: ctx, viewport }).promise;
      return canvas;
    }

    function containResizeDims(srcW, srcH, dstW, dstH){
      const scale = Math.min(dstW / srcW, dstH / srcH);
      return {
        w: Math.max(1, Math.round(srcW * scale)),
        h: Math.max(1, Math.round(srcH * scale)),
      };
    }

    async function renderToJpegBytesFromMagickImage(img, kind){
      // kind: "image" | "pdf"
      // å‘ãè£œæ­£
      try { img.autoOrient(); } catch {}

      // é€æ˜ã¯ç™½ã§æ½°ã™
      img.backgroundColor = Magick.MagickColors.White;
      try { img.alpha(Magick.AlphaAction.Remove); } catch {}

      // ---- è‰²ç®¡ç†ï¼ˆå¸Œæœ›ãƒ«ãƒ¼ãƒ«ï¼‰----
      // sRGBãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«ãŒãªã„ã¨ã€ŒæŒ‡å®šãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«ã¨ã—ã¦ã®å‡ºåŠ›ã€ãŒã§ããªã„ã®ã§è­¦å‘Š
      const warnings = [];

      if(!srgbProfile){
        warnings.push("sRGB ICCæœªæŒ‡å®šï¼ˆå‡ºåŠ›ã¯sRGBç›¸å½“ã®å¯èƒ½æ€§ï¼‰");
      }

      if(kind === "pdf"){
        // PDFã¯æ—¢ã«ãƒ©ã‚¹ã‚¿åŒ–æ¸ˆã¿ï¼ˆãƒ–ãƒ©ã‚¦ã‚¶å´è‰²å‡¦ç†ã®å½±éŸ¿ã‚’å—ã‘ã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ï¼‰
        if(srgbProfile) img.setProfile(srgbProfile);
      } else {
        const cs = img.colorSpace;

        if(cs === Magick.ColorSpace.CMYK || cs === Magick.ColorSpace.CMY){
          if(japanProfile && srgbProfile){
            const ok = img.transformColorSpace(japanProfile, srgbProfile, Magick.ColorTransformMode.HighRes);
            if(!ok) warnings.push("CMYKâ†’sRGBå¤‰æ›å¤±æ•—");
            img.setProfile(srgbProfile);
          } else {
            warnings.push("CMYKã ãŒICCä¸è¶³ï¼ˆJapanColor/sRGBï¼‰");
            // æœ€ä½é™ï¼šå¯èƒ½ãªã‚‰sRGBãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«ã ã‘ä»˜ã‘ã‚‹ï¼ˆãŸã ã—å³å¯†ã§ã¯ãªã„ï¼‰
            if(srgbProfile) img.setProfile(srgbProfile);
          }
        } else {
          // RGBç³»
          if(srgbProfile){
            const src = img.getColorProfile(); // embedded ICC
            if(src){
              const ok = img.transformColorSpace(src, srgbProfile, Magick.ColorTransformMode.HighRes);
              if(!ok) warnings.push("ICCâ†’sRGBå¤‰æ›å¤±æ•—");
              img.setProfile(srgbProfile);
            } else {
              // ICCç„¡ã—ã¯ã€ŒsRGBã¨ã—ã¦æ‰±ã†ã€é‹ç”¨ï¼ˆè­¦å‘Šã¯ã‚¿ã‚¤ãƒ«å´ã§æ—¢ã«å‡ºã—ã¦ã„ã‚‹ï¼‰
              img.setProfile(srgbProfile);
            }
          }
        }
      }

      // ---- ã‚µã‚¤ã‚ºåˆã‚ã›ï¼ˆãƒˆãƒªãƒŸãƒ³ã‚°ç„¡ã— / ç™½ä½™ç™½ï¼‰----
      const dims = containResizeDims(img.width, img.height, TARGET_W, TARGET_H);
      img.resize(dims.w, dims.h);

      // ä¸­å¤®é…ç½®ã§ 650x528 ã« extent
      img.extent(TARGET_W, TARGET_H, Magick.Gravity.Center, Magick.MagickColors.White);

      // ---- å‡ºåŠ›è¨­å®š ----
      img.density = new Magick.Density(OUT_DPI, OUT_DPI, Magick.DensityUnit.PixelsPerInch);
      img.quality = OUT_QUALITY;

      // JPEGã§æ›¸ãå‡ºã—
      const outU8 = await magickWriteCopyU8(img, Magick.MagickFormat.Jpeg);
      return { outU8, warnings };
    }

    async function processOneToJpegU8(it){
      if(it.kind === "dummy"){
        // ãƒ€ãƒŸãƒ¼ã¯ç”Ÿæˆã‚­ãƒ£ãƒ³ãƒã‚¹ã‹ã‚‰æ›¸ãå‡ºã™ï¼ˆå¿…ãšZIPã«å«ã‚ã‚‹ï¼‰
        const canvas = makeDummyExportCanvas();
        return await Magick.ImageMagick.readFromCanvas(canvas, async (img) => {
          try{
            // æ—¢ã«650x528ã ãŒã€å…±é€šãƒ‘ã‚¹ã§ç¢ºå®Ÿã«è¨­å®šãƒ»å‡ºåŠ›ã™ã‚‹
            return await renderToJpegBytesFromMagickImage(img, "image");
          } finally {
            img.dispose();
          }
        }, { alpha: false });
      }

      if(it.kind === "pdf"){
        const canvas = await rasterizePdfToCanvas(it.file);
        return await Magick.ImageMagick.readFromCanvas(canvas, async (img) => {
          try{
            return await renderToJpegBytesFromMagickImage(img, "pdf");
          } finally {
            img.dispose();
          }
        }, { alpha: false });
      } else {
        const u8 = await readFileAsU8(it.file);
        return await Magick.ImageMagick.read(u8, async (img) => {
          try{
            return await renderToJpegBytesFromMagickImage(img, "image");
          } finally {
            img.dispose();
          }
        });
      }
    }

    async function exportZip(){
      const prefix = (elPrefix.value || "").trim();
      if(!prefix){
        alert("å›ºå®šåï¼ˆprefixï¼‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„");
        return;
      }
      if(!magickReady){
        alert("ImageMagickã®åˆæœŸåŒ–ãŒå®Œäº†ã—ã¦ã„ã¾ã›ã‚“");
        return;
      }

      const digits = currentDigits();
      const zip = new JSZip();

      setStatus("æ›¸ãå‡ºã—ä¸­â€¦");
      log("export start. items=" + items.length);

      for(let i=0;i<items.length;i++){
        const it = items[i];
        const seq = i + 1;

        if(it.excluded){
          log("skip (excluded): " + it.file.name + " => " + pad(seq, digits));
          continue; // é€£ç•ªã¯è©°ã‚ãªã„ï¼ˆé‹ç”¨ãƒ«ãƒ¼ãƒ«ï¼‰
        }

        try{
          const { outU8, warnings } = await processOneToJpegU8(it);
          const outName = `${prefix}${pad(seq, digits)}.jpg`;
          zip.file(outName, outU8, { binary: true });

          if(warnings.length){
            log("warn: " + outName + " / " + warnings.join(", "));
          } else {
            log("ok: " + outName);
          }
        }catch(e){
          log("ERROR: " + it.file.name + " / " + (e?.message ?? e));
        }
      }

      const blob = await zip.generateAsync({ type: "blob" });
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = `${prefix}.zip`;
      a.click();

      setStatus("å®Œäº†");
      log("export done: " + a.download);
    }

    function clearAll(){
      // revoke object urls
      for(const it of items){
        if(it.thumbUrl) URL.revokeObjectURL(it.thumbUrl);
      }
      items.length = 0;
      elGrid.innerHTML = "";
      refreshSeqBadges();
      setStatus(magickReady ? "å¾…æ©Ÿä¸­" : "åˆæœŸåŒ–ä¸­â€¦");
      log("cleared");
    }

    // ---- D&D ----
    elDrop.addEventListener("dragover", (e)=>{ e.preventDefault(); elDrop.style.borderColor="#6aa9ff"; });
    elDrop.addEventListener("dragleave", ()=>{ elDrop.style.borderColor=""; });
    elDrop.addEventListener("drop", async (e)=>{
      e.preventDefault();
      elDrop.style.borderColor="";
      const files = [...(e.dataTransfer?.files ?? [])];
      if(!files.length) return;
      await addFiles(files);
      updateItemOrderFromDOM();
    });

    // ---- sortable ----
    new Sortable(elGrid, {
      group: { name: "grid", pull: true, put: true },
      animation: 150,
      onChoose: (evt) => {
        draggingId = evt?.item?.dataset?.id || null;
      },
      onUnchoose: () => {
        draggingId = null;
        elTrash?.classList.remove("hi");
      },
      onEnd: (evt) => {
        // ã‚´ãƒŸç®±ä¸Šã§ãƒ‰ãƒ­ãƒƒãƒ—ã•ã‚ŒãŸå ´åˆï¼ˆdropã‚¤ãƒ™ãƒ³ãƒˆãŒæ‹¾ãˆãªã„ç’°å¢ƒã®ä¿é™ºï¼‰
        try{
          const oe = evt?.originalEvent;
          if(oe && elTrash){
            const r = elTrash.getBoundingClientRect();
            const over = oe.clientX >= r.left && oe.clientX <= r.right && oe.clientY >= r.top && oe.clientY <= r.bottom;
            if(over){
              deleteCardById(evt?.item?.dataset?.id || draggingId || "");
              return;
            }
          }
        }catch{}
        updateItemOrderFromDOM();
        log("reordered");
      }
    });
    // ---- trash (drag here to delete) ----
    const elTrash = document.getElementById("trash");
    let draggingId = null;

    // SortableJS uses native DnD. We just remember which card is being dragged,
    // and delete it when dropped onto the trash area (without moving DOM into trash).
    elGrid.addEventListener("dragstart", (e) => {
      const card = e.target?.closest?.(".card");
      if(!card) return;
      draggingId = card.dataset.id || null;
      try{
        e.dataTransfer?.setData("text/plain", draggingId || "");
        e.dataTransfer.effectAllowed = "move";
      }catch{}
    }, true);

    elGrid.addEventListener("dragend", () => {
      draggingId = null;
      elTrash?.classList.remove("hi");
    });

    function deleteCardById(id){
      if(!id) return;
      const idx = items.findIndex(x => x.id === id);
      if(idx >= 0){
        const it = items[idx];
        if(it?.thumbUrl) URL.revokeObjectURL(it.thumbUrl);
        items.splice(idx, 1);
      }
      const card = elGrid.querySelector(`.card[data-id="${id}"]`);
      card?.remove();
      refreshSeqBadges();
      log("deleted: " + id);
    }

    if(elTrash){
      elTrash.addEventListener("dragenter", (e) => {
        e.preventDefault();
        elTrash.classList.add("hi");
      });
      elTrash.addEventListener("dragover", (e) => {
        e.preventDefault();
        elTrash.classList.add("hi");
        try{ e.dataTransfer.dropEffect = "move"; }catch{}
      });
      elTrash.addEventListener("dragleave", (e) => {
        const rt = e.relatedTarget;
        if(rt && elTrash.contains(rt)) return;
        elTrash.classList.remove("hi");
      });
      elTrash.addEventListener("drop", (e) => {
        e.preventDefault();
        elTrash.classList.remove("hi");

        // ignore dropping local files onto the trash area
        if(e.dataTransfer?.files && e.dataTransfer.files.length > 0) return;

        const id = (e.dataTransfer?.getData("text/plain") || draggingId || "").trim();
        // wait a tick so Sortable finishes its end/cancel logic
        setTimeout(() => deleteCardById(id), 0);
      });
    }


    // ---- buttons ----
    elBtnDummy.addEventListener("click", ()=>{
      addDummy();
      updateItemOrderFromDOM();
    });

    elBtnExport.addEventListener("click", async ()=>{
      const ok = await showConfirm({
        title: "ç¢ºèª",
        message: "ZIPã‚’æ›¸ãå‡ºã—ã¾ã™ã€‚ã‚ˆã‚ã—ã„ã§ã™ã‹ï¼Ÿ",
        okText: "æ›¸ãå‡ºã—",
        cancelText: "æˆ»ã‚‹",
        okDanger: true
      });
      if(!ok) return;
      await exportZip();
    });

    elBtnClear.addEventListener("click", async ()=>{
      const ok = await showConfirm({
        title: "ç¢ºèª",
        message: "ä¸€è¦§ã‚’ã‚¯ãƒªã‚¢ã—ã¾ã™ã€‚ã‚ˆã‚ã—ã„ã§ã™ã‹ï¼Ÿ",
        okText: "ã‚¯ãƒªã‚¢",
        cancelText: "æˆ»ã‚‹",
        okDanger: true
      });
      if(!ok) return;
      clearAll();
    });
    elPrefix.addEventListener("input", refreshSeqBadges);

    // ---- icc inputs ----
    elSrgbIcc.addEventListener("change", async ()=>{
      const f = elSrgbIcc.files?.[0];
      if(!f) return;
      await setProfileFromInput(f, "srgb");
      // æ—¢å­˜ã‚¿ã‚¤ãƒ«ã®è­¦å‘Šã‚’æ›´æ–°ã—ãŸã„å ´åˆã¯ã€é‹ç”¨ã«åˆã‚ã›ã¦å†è§£æã‚’è¿½åŠ ã—ã¦OK
    });
    elJapanIcc.addEventListener("change", async ()=>{
      const f = elJapanIcc.files?.[0];
      if(!f) return;
      await setProfileFromInput(f, "japan");
    });

    // ---- init ----
    (async ()=>{
      setStatus("ImageMagick åˆæœŸåŒ–ä¸­â€¦");
      log("init magick-wasm...");

      // magick.wasm ã®URLã‚’æŒ‡å®šã—ã¦åˆæœŸåŒ–
      await Magick.initializeImageMagick(new URL("https://cdn.jsdelivr.net/npm/@imagemagick/magick-wasm@0.0.37/dist/magick.wasm"));

      magickReady = true;
      setStatus("å¾…æ©Ÿä¸­ï¼ˆD&Dã—ã¦ãã ã•ã„ï¼‰");
      log("magick-wasm ready.");
      // profilesã®è‡ªå‹•ãƒ­ãƒ¼ãƒ‰ã¯è¡Œã„ã¾ã›ã‚“ï¼ˆGitHub Pagesä¸Šã§404ãƒ­ã‚°ãŒå‡ºã‚‹ã®ã‚’é¿ã‘ã‚‹ãŸã‚ï¼‰ã€‚å¿…è¦ãªã‚‰ä¸Šã®ãƒ•ã‚¡ã‚¤ãƒ«é¸æŠã§æŒ‡å®šã—ã¦ãã ã•ã„ã€‚
      await refreshTiffThumbnails();

      refreshSeqBadges();
    })().catch(err=>{
      setStatus("åˆæœŸåŒ–å¤±æ•—");
      log("FATAL init error: " + (err?.message ?? err));
      console.error(err);
    });
  </script>
</body>
</html>
